# Structs and Interfaces 结构体和接口

1. [Methods 方法](#Methods方法)
   1. [方法与结构体的关系](#方法与结构体的关系)
2. [Interfaces 接口](#Interfaces接口)

# Methods 方法

方法是一种特殊类型的**函数**。是**作用在`接收者(receiver)`上的一个函数**，`接收者`是某种类型的**变量**。接收者的类型不能是一个接口类型；也不能是一个指针类型，但是可以使任何其他允许类型的指针。代码示例[methods](./method/method.go)

定义格式：`func (RecvID RecvType) MethodID(ParameterList) (ReturnValueList) {...}`。RecvID 就是 receiver 的标识符，即：Recv 类型的**变量**。如果 Method 不需要 Recv 的值，可以用`_`代替 RecvID。定义方法就是用类型来定义其方法

调用格式：`RecvID.MethodID()`。i.e.调用某个类型上的方法。因为方法是作用在类型上的，所以不用初始化，直接调用即可。

### 方法与结构体的关系

比如：有一个矩形的结构体，里面有两个属性，长和宽；如果想让整个矩形得出面积，需要一个方法，这个求面积的方法可以给矩形发消息，告诉矩形这是你求面积的方法；这时候这个矩形就可以拿着这个方法，自己算出自己的面积

用白话说：其实一个结构体就是一个对象，这个对象有很多很多的属性，想要根据这个对象的属性来得出某些结果，就可以将这个对象作用在某个方法上，这个方法就可以根据这个对象的某些属性进行计算来得出结果。再举一个例子，有一个人有多种属性(身高，体重，性别，腰围)；根据这些属性，可以创建一个计算体型的方法，这个方法根据这些属性中的 1 个或者多个计算出结果是偏瘦、偏胖还是适中。

# Interfaces 接口

接口是一组仅包含方法名、参数、返回值的未具体实现的方法的集合。接口也是类型的一种。当一个类型定义了接口中所有的方法，就称这个类型实现了该接口。接口指定了一个类型应该具有的方法，并由该类型决定如何实现这些方法。接口里不能包含变量。代码示例：[interface.go](./interface/interface.go)（接口也可以算自定义类型的一种，使用关键字 type 与 interface，所以可以对接口赋值，并且接口可以动态改变其自身的类型，只要某个类型实现了该接口，该接口的类型在使用这个类型的时候，就会变成这个类型，这称为接口的[**多态性**](#接口的多态性)）
使用接口的好处：详见代码[interface1.go](./interface/practice/interface_salary.go)中相关好处的说明
例如：`WashingMachine`是一个含有`Cleaning()`和`Drying()`两个方法的接口。任何定义了`Cleaning()`和`Drying()`方法的类型，都称该类型实现了`WashingMachine`接口。
接口定义格式：

```go
type InterfaceID interface {
	Method1(ParameterList) ReturnType
	Method2(ParameterList) ReturnType
	...
}
```

接口的声明：`var InterfaceVarID InterfaceID`。接口可以有值，VarID 是一个多字(multiword)。数字结构，值为 nil。本质上是一个指针，但又不完全是一回事。
接口的引用：`InterfaceVarID.MethodID()`。在引用前需要先给 InterfaceVarID 赋值，可以使用`InterfaceVarID=TypeVarID`用类型变量对接口变量进行赋值(i.e.接口变量包含一个指向类型变量的引用)，通过这个引用，接口可以调用类型上的方法。这种方式使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。

接口的特性：

1. 指向接口值得**指针**是**非法**的，不仅一点用没有，还会导致代码错误。说白了就是使用接口时不要带 `*` 符号
2. 类型(e.g.struct、slice 等)实现了接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的 i.e.**Implement Interface(实现接口)**，同时方法集也构成了该类型的接口。实现了 InterfaceID 接口类型的变量可以赋值给 VarID(接收者值)，此时方法表中的指针会指向被实现的接口方法。如果另一个类型(也实现了该接口)的变量被赋值给 VarID，这两者(指针和方法实现)也会随之改变。
3. 多个类型可以实现同一个接口，所以类型不用显式得声明其实现了哪一个接口，所以接口会被隐式得实现。i.e.接口里只需要看到方法是什么，不用关心方法作用在哪个类型上。
4. 一个类型可以实现多个接口
5. 实现某个接口的类型可以有其他办法
6. 接口类型可以包含一个实例的引用，该实例的类型实现了此接口(接口是动态类型)。e.g.声明一个接口类型的变量。
   注意：即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。
7. 有的时候，也会以一种稍微不同的方式来使用接口这个词：从类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显式地为这些导出方法额外定一个接口而已。
   **接口嵌套接口**
   一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。
   比如下面的例子接口`File`包含了`ReadWrite`和`Lock`的所有方法，它还额外有一个`Close()`方法。

```go
type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type Lock interface {
    Lock()
    Unlock()
}

type File interface {
    ReadWrite
    Lock
    Close()
}
```

**空接口**
空接口或者最小接口不包含任何方法，它对实现不做任何要求
定义格式：`type InterfaceID interface {}`
可以给一个空接口类型的变量赋任何类型的值

## 接口的多态性

代码示例 1：[interface_formula.go](/7.structs_and_interfaces/interface/practice/interface_formula.go)其中接口变量的类型可以动态得随着不同的值而变化为对应的类型
代码示例 2：[interface_salary.go](/7.structs_and_interfaces/interface/practice/interface_salary.go)其中接口变量切片中的元素可以是任意类型；不像普通的切片，所有元素都是同一个类型

### Type Assertion(类型断言)

**检测和转换接口变量的类型**
一个接口类型的变量`InterfaceVar`中可以包含任何类型的值，必须有一种方式来检测它的动态类型 i.e.运行时在接口变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用**TypeAssertion(类型断言)**来测试在当前执行该语句的时候`InterfaceVar`所定义的接口是否是`Type`这个类型
使用格式：`v := InterfaceVar.(Type)`
类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：

```go
if v, ok := InterfaceVar.(Type); ok {  // checked type assertion
    Process(v)
    return
}
```

如果转换合法，则`v`是`InterfaceVar`转换到类型`Type`的值，`ok`会是`true`；否则`v`是类型`Type`的零值,`ok`是`false`，也没有运行时错误发生。

> 说白了，就是给 v 赋值

# 总结：

Interface(接口) 在 Go 语言有着至关重要的地位。接口是 Go 语言这个类型系统的基石，让 Go 语言在基础编程哲学的探索上达到了前所未有的高度。
接口解除了类型依赖，有助于减少用户的可视方法，屏蔽了内部结构和实现细节。但是接口实现机制会有运行期开销，也不能滥用接口。相对于包，或者不会频繁变化的内部模块之间，不需要抽象出接口来强行分离。接口最常用的使用场景，是对包提供访问，或预留扩展空间。也是体现多态很重要的手段。说到底，接口的意义：就是解耦合，程序和程序之间的关联程度，降低耦合性。

方法、结构体、接口，这三者在项目开发中，占有很大的比重，也是一个 go 项目的设计思路。

我们设计一个事物，这个事物就是一个结构体。

然后可以对这个结构体中的数据进行增删改查等操作，每个操作都可以是一个方法。

Go 是静态类型的编程语言，自 2009 年发布以来，已经十多岁了。现在，Go 广泛应用于云原生系统、微服务、web 开发、运维等场景，并且在 webassembly、嵌入式等也有进一步的探索。尤其在中国，Go 语言越来越多的被众多公司和开发者所采用，相关的研究文章也不断的涌现，从编译器的优化、运行时的内部机制、标准库的设计、语言规范的探索、第三库的研究和应用、产品中的应用、不同语言的比较等等目不暇接。

Go 是面向对象的编程语言吗？

官方 FAQ 给出了标准答案: Yes and No。

当然，Go 有面向对象编程的类型和方法的概念，但是它没有继承(hierarchy)一说。Go 语言的接口实现和其它的编程语言不一样，Go 开发者的初衷就是保证它易于使用，用途更广泛。

还有一种“模拟”产生子类的方法，拿就是通过在类型中嵌入其它的类型，但是这是一种“组合”的方式，而不是继承。

没有了继承， Go 语言的对象变得比 C++和 Java 中更轻量级。

在 Go 语言中，接口定义了一套方法的集合，任何实现这些方法的对象都可以被认为实现了这个接口，这也称作 Duck Type。这不像其它语言比如 java,需要预先声明类型实现了某个或者某些接口，这使得 Go 接口和类型变得很轻量级，它解耦了接口和具体实现的硬绑定。显然这是 Go 的开发者深思熟虑的一个决定。

> if something looks like a duck, swims like a duck and quacks like a duck then it’s probably a duck.

因为没有继承，你也只能通过 Go 接口实现面向对象编程的多态。本身 Go 接口在内部实现上也是一个(其实是两种,其中一种专门处理 interface{})结构体,它的虚函数指向具体的类型的实现。在编译代码的时候，Go 编译器还会做优化，不需要接口的时候，它会使用具体的方法来代替接口使用，这样进一步优化性能，这叫做 devirtualize 调用。

## 总结 2-白话文

但是，如果想让

而如果想要让别人也可以操作这个结构体，就可以把这些方法统一起来，形成一个接口。如果只想让别人进行部分操作，那么就定义一个包含部分方法的接口，提供给别人。

这时，别人可以直接通过接口调用这些方法，而不用先实例化一个结构体，再通过结构体调用了。
