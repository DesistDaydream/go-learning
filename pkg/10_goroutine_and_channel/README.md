# Go 语言的并发

## **不要通过共享来通信，而要通过通信来共享。**

通过`Goroutines协程`与`Channels通道`实现`并发编程`

**并发**与**并行**的区别

1. 并发：一个处理器或者内核上，一个并发程序可以使用多个线程来**交替运行**。反义词为顺序
   1. 实际例子：你有一张嘴，电话来了，你停了下来接了电话，吃一口说一句话，直到说完话并且吃完饭，这是并发
1. 并行：多个处理器或者多核上，一个程序在某个时间、在多个处理器上**同时运行**。反义词为串行
   1. 实际例子：你有两张嘴，电话来了，你一边打电话一边吃饭，直到说完话并且吃完饭，这是并行

并行是并发的真子集。并发不全是并行，但并行一定并发。(单核并发不并行，多核并行也属于并发)，除非该程序无法使用多线程执行任务。

并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信。比如运行在两个 CPU 上的两个组件之间需要互相通信。并发系统上，这种通信开销很小。但在多核的并行系统上，组件间的通信开销就很高了。所以，并行不一定会加快运行速度！

一个程序是运行在机器上的一个进程，进程是一个运行在自己内存空间里的独立执行体。一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间在一起工作的执行体。几乎所有`正式`的程序都是多线程的，以便让用户或计算机不必等待，或能够同时服务多个请求(e.g.Web 服务器)，或增加性能和吞吐量。

不要使用全局变量或共享内存，他们会给代码在并发运算的时候带来危险。

## Goroutines 协程

处理应用程序**并发**功能的就是`Goroutines`

Go 协程是与其他函数或方法一起并发运行的函数或方法。

调用函数或者方法时，在前面加上关键字 go，可以让一个新的 Go 协程并发地运行。i.e.有关键字`go`的函数或方法，即算协程，可以并发运行。

main()函数算主协程，可以没有`go`关键字

一个基本的协程代码示例：[goroutine.go](/10.goroutines_and_channels/goroutine.go)

## Channels 通道

通道，可以想象成 Go 协程之间通信的管道。如同管道中的水会从一端流到另一端，通过使用通道，数据也可以从一端发送，在另一端接收。

如果两个协程需要通信，则必须要给它们同一个通道作为参数才可以。

基本声明格式：`var ChanID chan Type`。声明一个通道，指定这个通道里可以传输的类型是什么
初始化格式：`ChanID = make(chan Type)`。因为 channel 是引用类型，所以可以使用 make()函数来给它分配内存

channel 的操作符：`<-`。这个操作符表示数据按照箭头的方向流动。下面有几个例子：

1. `ch <- int1`。流向通道(发送)。表示发送变量 int1 的数据到通道 ch 中。i.e.int1 变量中的数据会发送给通道 ch。
1. `int2 = <- ch`。从通道流出(接收)。表示变量 int2 从通道 ch 中接收数据。i.e.ch 中的数据会发送给 int2
1. `<- ch`。单独调用通道的值，当前值会被丢弃。

一个基本的通道代码示例：[channel.go](/10.goroutines_and_channels/channel.go)
代码示例：[goroutineChannel.go](/10.goroutines_and_channels/goroutineChannel.go)展示了一个通道连通了两个协程，使得数据从一个协程进入通道，再从通道另一端出去到另一个协程的过程

比如聊天室功能中俩人聊天，两个 goroutine 就是两人的聊天窗口，channel 就是连接两人的管道，直到一个人向 channel 发送消息前，channel 都是阻塞的，当发送消息后，消息就会从 channel 的另一头流出，让另一个人收到

**通道阻塞**

默认情况下，数据通信是同步且无缓冲的，i.e.一边发就需要一边接收，在有接收者接收数据之前，发送不会结束，也不会继续发送新数据，这种情况称为**阻塞**。必须要有一个接收者准备好接收通道的数据，然后发送者可以直接把数据发送给接收者。或者可以使用[带缓冲的通道](#带缓冲的通道)，这样，在给通道发送数据时，可以把数据先存储在缓冲区，而不用直接让接收者接收。

对于通道阻塞有非常严格的规定：

1. 对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。
1. 对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。

为通道提供数据的也叫**生产者**，从通道中拿去数据的也叫**消费者**

**注意**

channel.go 例子中，有通道的错误使用方法，请注意！

### 带缓冲的通道

格式：`ChanID = make(chan Type, CapValue)`。CapValue 为容量值。如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。

### 单向通道

- `var VarID chan<- int`。通道仅能发送数据。i.e.关键字：`chan<-`
- `var VarID <-chan int`。通道仅能接收数据。i.e.关键字：`<-chan`

只接收的通道（<-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。
