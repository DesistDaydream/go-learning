package main

import "fmt"

func main() {
	// []byte 是将字符串中每个字符以 ASCII 的十进制数字存储到一个字节数组中（默认使用 UTF-8 规则）
	// 每个字符占一个字节。若是不在 ASCII 表中的字符（比如中文），则先要按照 Unicode 规则找到该字符对应的编号，然后转换为 1 ~ 4 Byte，将拆分成的每个 Byte 进行存储
	// 数组中的值分别为 97(a) 98(b) 99(c) 228 189 160(228 189 160 合起来是: 你) 229 165 189(229 165 189 合起来是: 好)
	b := []byte("abc你好")
	a := []byte{97, 98, 99, 228, 189, 160, 229, 165, 189}
	fmt.Println(b)
	fmt.Println(string(a))

	// 具体字符如何存储成字节数组，可以参考 https://github.com/golang/go/blob/go1.24.2/src/unicode/utf8/utf8.go#L110
	// 更多的 Unicode 规则详见笔记: https://github.com/DesistDaydream/notes-learning/blob/main/content/zh-cn/docs/8.通用技术/编码与解码/字符的编码与解码/字符的编码与解码.md
}

// 1 Bytes = 8 bit, 最多 8 个 1，最大 255，可以表示 0 ~ 255 这 256 个数字。每个 Bytes 的数字不会超过 255

// ######## ######## ######## ######## ######## ########

// 下面是将 string 转为 []byte 的简略过程
// 逐一读取字符
// abc 比较简单暂时忽略
// 从数据库中查到“你”的 Unicode 编号为 20320，处在 2048 ~ 65535 这段编号的模板（1110???? 10?????? 10??????）中，需要使用 3 Bytes 存储
// 转换为二进制后为 0100 1111 0110 0000，套入到模板中后，得到如下结果
// 11100100 十进制: 228
// 10111101 十进制: 189
// 10100000 十进制: 160
// 所以需要用 228, 189, 160 这三个 Bytes 储存“你”这个字符
// “好”的逻辑与上面相同，不再赘述

// ######## ######## ######## ######## ######## ########

// 下面是将 []byte 转为 string 的简略过程描述：
// 逐一读取元素
// 前面三个元素，转成二进制后，符合 0 ~ 127 这段编号的模板（0???????）
// 只需要读取 1 个 Bytes，即可组成一个完整的字符。
// 97 01100001
// 98 01100010
// 99 01100011
//
// 当读取数组中元素到 228 时，发现符合 2048 ~ 65535 这段编号的模板（1110???? 10?????? 10??????）了，
// 所以从 228 开始必须读取 3 个 Bytes，这 3 个 Bytes 组成一个完整的字符。
// 228 11100100
// 189 10111101
// 160 10100000
// 0100111101100000
//
// 下面的逻辑与上面的逻辑一致，不再赘述
// 229 11100101
// 165 10100101
// 189 10111101
// 0101100101111101
