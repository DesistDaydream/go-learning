# Structs and Interfaces结构体和接口
1. [Structs 结构体](#1.Structs结构体)  
2. [Methods 方法](#Methods方法) 
   1. [方法与结构体的关系](#方法与结构体的关系) 
3. [Interfaces 接口](#Interfaces接口)  
4. [Reflection 反射](#Reflection反射)

## Structs 结构体  
**Structs(结构体)** 是一种复合数据类型，当需要一个[自定义Type](/1.Type/README.md)，且这个 Type 由一系列的属性组成，每个属性都有自己的 **类型** 和 **值** 的时候，就需要使用 Structs，Structs 把数据聚集在一起，然后访问这些数据的时候，好像这些数据是一个独立实体的一部分。Structs 也是值类型，可以通过 `* new()` 函数创建。

组成结构体的属性分两部分
* FIELD(字段)
* BaseType(基础类型)
> 基础类型可以是另一个结构体,表示该结构体包含另一个结构体

每个字段都有其对应的基础数据类型，在一个结构体中，FIELD名字必须是唯一的。代码示例：[struct.go](/7.Structs_Interfaces/struct/struct.go)
结构体的定义格式：
```go
type StructID struct {
	FIELD1 BaseType1 ["TAG"]
	FIELD2 BaseType2 [`TAG`]
	...
}
```
也可以使用简单的方法定义：`type T struct {a, b int}`

结构体的初始化格式：`VarID ：= new(PackageID.StructID)`。若初始化的结构体为当前包的，则可以省略 PackageID

结构体中字段的引用格式：`StrcutID.FIELD1`。结构体名，中间跟一个点，再接该结构体内的字段名。
在Go语言中，这个`.`点符号叫做**选择器(selector)**。无论定义的变量是一个结构体类型还是一个结构体类型指针，都是用同样的**选择器符(selector-notation)**来引用结构体的字段。

TAG
除了 FIeld 和 BaseType 之外，还可以给该属性添加 TAG(标签)，TAG使用`双引号`或者`重音号`来表示。这些TAG能被用来做文档或者重要的标签。  
TAG里面的内容在正常编程中没有作用。一般在反射、某些第三方库(比如gin的数据绑定功能)、等等地方可以起到关键的作用。

## Methods 方法
方法是一种特殊类型的**函数**。是**作用在`接收者(receiver)`上的一个函数**，`接收者`是某种类型的**变量**。接收者的类型不能是一个接口类型；也不能是一个指针类型，但是可以使任何其他允许类型的指针。代码示例[methods](/7.Structs_Interfaces/method/method.go)  

定义格式：`func (RecvID RecvType) MethodID(ParameterList) (ReturnValueList) {...}`。RecvID就是receiver的标识符，即：Recv类型的**变量**。如果Method不需要Recv的值，可以用`_`代替RecvID。定义方法就是用类型来定义其方法  

调用格式：`RecvID.MethodID()`。i.e.调用某个类型上的方法。因为方法是作用在类型上的，所以不用初始化，直接调用即可。

### 方法与结构体的关系
比如：有一个矩形的结构体，里面有两个属性，长和宽；如果想让整个矩形得出面积，需要一个方法，这个求面积的方法可以给矩形发消息，告诉矩形这是你求面积的方法；这时候这个矩形就可以拿着这个方法，自己算出自己的面积

用白话说：其实一个结构体就是一个对象，这个对象有很多很多的属性，想要根据这个对象的属性来得出某些结果，就可以将这个对象作用在某个方法上，这个方法就可以根据这个对象的某些属性进行计算来得出结果。再举一个例子，有一个人有多种属性(身高，体重，性别，腰围)；根据这些属性，可以创建一个计算体型的方法，这个方法根据这些属性中的1个或者多个计算出结果是偏瘦、偏胖还是适中。

## Interfaces 接口  
接口是一组仅包含方法名、参数、返回值的未具体实现的方法的集合。接口也是类型的一种。当一个类型定义了接口中所有的方法，就称这个类型实现了该接口。接口指定了一个类型应该具有的方法，并由该类型决定如何实现这些方法。接口里不能包含变量。代码示例：[interface.go](/7.Structs_Interfaces/interface/interface.go)（接口也可以算自定义类型的一种，使用关键字type与interface，所以可以对接口赋值，并且接口可以动态改变其自身的类型，只要某个类型实现了该接口，该接口的类型在使用这个类型的时候，就会变成这个类型，这称为接口的[**多态性**](#接口的多态性)）
使用接口的好处：详见代码[interface1.go](/7.Structs_Interfaces/interface1.go)中相关好处的说明  
例如：`WashingMachine`是一个含有`Cleaning()`和`Drying()`两个方法的接口。任何定义了`Cleaning()`和`Drying()`方法的类型，都称该类型实现了`WashingMachine`接口。
接口定义格式：
```go
type InterfaceID interface {
	Method1(ParameterList) ReturnType
	Method2(ParameterList) ReturnType
	...
}
```
接口的声明：`var InterfaceVarID InterfaceID`。接口可以有值，VarID是一个多字(multiword)。数字结构，值为nil。本质上是一个指针，但又不完全是一回事。  
接口的引用：`InterfaceVarID.MethodID()`。在引用前需要先给InterfaceVarID赋值，可以使用`InterfaceVarID=TypeVarID`用类型变量对接口变量进行赋值(i.e.接口变量包含一个指向类型变量的引用)，通过这个引用，接口可以调用类型上的方法。这种方式使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。

接口的特性：
1. 指向接口值得指针是非法的，不仅一点用没有，还会导致代码错误  
2. 类型(e.g.struct、slice等)实现了接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的i.e.**实现接口**，同时方法集也构成了该类型的接口。实现了InterfaceID接口类型的变量可以赋值给VarID(接收者值)，此时方法表中的指针会指向被实现的接口方法。如果另一个类型(也实现了该接口)的变量被赋值给VarID，这两者(指针和方法实现)也会随之改变。  
3. 多个类型可以实现同一个接口，所以类型不用显式得声明其实现了哪一个接口，所以接口会被隐式得实现。i.e.接口里只需要看到方法是什么，不用关心方法作用在哪个类型上。  
4. 一个类型可以实现多个接口  
5. 实现某个接口的类型可以有其他办法  
6. 接口类型可以包含一个实例的引用，该实例的类型实现了此接口(接口是动态类型)。e.g.声明一个接口类型的变量。  
注意：即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。 
7. 有的时候，也会以一种稍微不同的方式来使用接口这个词：从类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显式地为这些导出方法额外定一个接口而已。  
**接口嵌套接口**  
一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。  
比如下面的例子接口`File`包含了`ReadWrite`和`Lock`的所有方法，它还额外有一个`Close()`方法。
```go
type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type Lock interface {
    Lock()
    Unlock()
}

type File interface {
    ReadWrite
    Lock
    Close()
}
```

**空接口**
空接口或者最小接口不包含任何方法，它对实现不做任何要求
定义格式：`type InterfaceID interface {}`
可以给一个空接口类型的变量赋任何类型的值

### 接口的多态性
代码示例1：[interface1.go](/7.Structs_Interfaces/interface.go)其中接口变量的类型可以动态得随着不通的值而变化为对应的类型
代码示例2：[interface1.go](/7.Structs_Interfaces/interface1.go)其中接口变量切片中的元素可以是任意类型；不像普通的切片，所有元素都是同一个类型

**检测和转换接口变量的类型**  
一个接口类型的变量`InterfaceVar`中可以包含任何类型的值，必须有一种方式来检测它的动态类型i.e.运行时在接口变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用`TypeAssertion类型断言`来测试在当前执行该语句的时候`InterfaceVar`所定义的接口是否是`Type`这个类型  
使用格式：`v := InterfaceVar.(Type)`  
类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：  
```go
if v, ok := InterfaceVar.(Type); ok {  // checked type assertion
    Process(v)
    return
}
```
如果转换合法`v`是`InterfaceVar`转换到类型`Type`的值，`ok`会是`true`；否则`v`是类型`Type`的零值,`ok`是`false`，也没有运行时错误发生。  

## reflection 反射  
反射是用程序检查其所拥有的结构，尤其是类型的一种能力。可以通过反射来分析一个结构体。反射可以在运行时检查类型和变量，例如它的大小、方法和动态的调用这些方法。  
`reflect.TypeOf()`和`reflect.ValueOf()`两个函数返回被检查对象的类型和值。e.g.`var x float64 = 3.4`,那么reflect.TypeOf(x)返回float64，reflect.ValueOf(x)返回 

忠告：反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有三。  
1. 基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间。  
2. 即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受interface{}或reflect.Value类型参数的函数维护说明文档。  
3. 基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以使用反射可能会使程序更加清晰。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。  

# 总结：
方法、结构体、接口，这三者在项目开发中，占有很大的比重，也是一个 go 项目的设计思路。

我们设计一个事物，这个事物就是一个结构体。

然后可以对这个结构体中的数据进行增删改查等操作，每个操作都可以是一个方法。

而如果想要让别人也可以操作这个结构体，就可以把这些方法统一起来，形成一个接口。如果只想让别人进行部分操作，那么就定义一个包含部分方法的接口，提供给别人。

这时，别人可以直接通过接口调用这些方法，而不用先实例化一个结构体，再通过结构体调用了。
